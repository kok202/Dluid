package org.kok202.dluid.canvas.block;

import javafx.geometry.Point3D;
import javafx.scene.Group;
import javafx.scene.paint.Color;
import lombok.AccessLevel;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import org.kok202.dluid.canvas.CanvasConstant;
import org.kok202.dluid.canvas.entity.ExtraBlockProperty;
import org.kok202.dluid.canvas.polygon.block.BlockFace;
import org.kok202.dluid.canvas.polygon.block.BlockHexahedron;
import org.kok202.dluid.canvas.singleton.CanvasSingleton;
import org.kok202.dluid.canvas.util.BlockNodeUtil;
import org.kok202.dluid.domain.entity.Layer;
import org.kok202.dluid.domain.entity.enumerator.LayerType;
import org.kok202.dluid.domain.exception.CanNotFindGraphNodeException;
import org.kok202.dluid.domain.structure.GraphNode;

import java.util.ArrayList;
import java.util.List;

@ToString(exclude = {"blockHexahedronList"})
@EqualsAndHashCode(exclude = {"blockHexahedronList"})
// IMPORTANT : Because using hash set.
// Or stack overflow can be generated by bidirectional reference.
public abstract class BlockNode {

    private final int BLOCK_HEXAHEDRON_SIZE;

    @Getter
    private BlockInfo blockInfo;

    @Getter
    private Layer blockLayer;

    @Getter(AccessLevel.PROTECTED)
    private List<BlockHexahedron> blockHexahedronList;

    public BlockNode(Layer layer, int BLOCK_HEXAHEDRON_SIZE) {
        this.BLOCK_HEXAHEDRON_SIZE = BLOCK_HEXAHEDRON_SIZE;
        this.blockInfo = new BlockInfo(layer, BLOCK_HEXAHEDRON_SIZE);
        this.blockLayer = layer;
        clearHexahedronList();
        createBlockModel(layer);
    }

    protected void setBlockColor(int blockHexahedronIndex, BlockFace blockFace, Color color){
        getBlockInfo().getColorMapList().get(blockHexahedronIndex).put(blockFace, color);
    }

    protected void setBlockCover(int blockHexahedronIndex, BlockFace blockFace, String texture){
        getBlockInfo().getTextureSourceMapList().get(blockHexahedronIndex).put(blockFace, texture);
    }

    protected void refreshBlockCover(){
        for(int i = 0; i < BLOCK_HEXAHEDRON_SIZE; i++){
            BlockHexahedron blockHexahedron = blockHexahedronList.get(i);

            // Reload block color cover
            getBlockInfo().getColorMapList().get(i).put(BlockFace.TOP, (isPossibleToAppendFrontByDirection())? CanvasConstant.CONTEXT_COLOR_POSSIBLE_APPEND : CanvasConstant.CONTEXT_COLOR_IMPOSSIBLE_APPEND);
            getBlockInfo().getColorMapList().get(i).put(BlockFace.BOTTOM, (isPossibleToAppendBackByDirection())? CanvasConstant.CONTEXT_COLOR_POSSIBLE_APPEND : CanvasConstant.CONTEXT_COLOR_IMPOSSIBLE_APPEND);
            blockHexahedron.setColorMap(getBlockInfo().getColorMapList().get(i));

            // Reload block texture cover
            blockHexahedron.setTextureSourceMap(getBlockInfo().getTextureSourceMapList().get(i));
            blockHexahedron.refreshBlockCover();
        }
    }

    public void translatePosition(double x, double y, double z){
        Point3D currentPosition = blockInfo.getPosition();
        Point3D targetPosition = currentPosition.add(x,y,z);
        setPosition(targetPosition.getX(), targetPosition.getY(), targetPosition.getZ());
    }

    public void addedToScene(Group sceneRoot, Point3D insertingPoint) {
        setPosition(insertingPoint.getX(), insertingPoint.getY(), 0);
        blockHexahedronList.forEach(blockHexahedron -> blockHexahedron.addedToScene(sceneRoot));
    }

    public final void deleteHexahedrons(){
        Group sceneRoot = CanvasSingleton.getInstance().getMainCanvas().getMainScene().getSceneRoot();
        blockHexahedronList.forEach(blockHexahedron -> {
            blockHexahedron.removedFromScene(sceneRoot);
        });
        clearHexahedronList();
    }

    private void clearHexahedronList(){
        if(blockHexahedronList == null){
            blockHexahedronList = new ArrayList<>();
        }
        blockHexahedronList.clear();
        for(int i = 0; i < BLOCK_HEXAHEDRON_SIZE; i++){
            blockHexahedronList.add(null);
        }
    }

    // NOTICE : Multi layer for input is only available on merge and switch layer
    public boolean isPossibleToAppendFrontByConnection() {
        try{
            GraphNode<BlockNode> thisGraphNode = CanvasSingleton.getInstance()
                    .getBlockNodeManager()
                    .findGraphNodeByLayerId(this.getBlockLayer().getId());
            return thisGraphNode.getIncomingNodes().isEmpty();
        }catch (CanNotFindGraphNodeException canNotFindGraphNodeException){
            // When initialize, it is not registered in graph manger.
            return true;
        }
    }

    // NOTICE : Multi layer for input is only available on merge and switch layer
    public boolean isPossibleToAppendFrontByDirection() {
        try{
            GraphNode<BlockNode> thisGraphNode = CanvasSingleton.getInstance()
                    .getBlockNodeManager()
                    .findGraphNodeByLayerId(this.getBlockLayer().getId());
            return thisGraphNode.getIncomingNodes().isEmpty();
        }catch (CanNotFindGraphNodeException canNotFindGraphNodeException){
            // When initialize, it is not registered in graph manger.
            return true;
        }
    }

    public boolean isPossibleToAppendBackByConnection() {
        return true;
    }

    public boolean isPossibleToAppendBackByDirection() {
        try{
            GraphNode<BlockNode> thisGraphNode = CanvasSingleton.getInstance()
                    .getBlockNodeManager()
                    .findGraphNodeByLayerId(this.getBlockLayer().getId());
            return thisGraphNode.getOutgoingNodes()
                    .stream()
                    .filter(blockNodeGraphNode -> blockNodeGraphNode.getData().getBlockLayer().getType() != LayerType.PIPE_LAYER)
                    .count() == 0;
        }catch (CanNotFindGraphNodeException canNotFindGraphNodeException){
            // When initialize, it is not registered in graph manger.
            return true;
        }
    }

    public double calcHeight(){
        return BlockNodeUtil.getBlockNodeZ(getBlockLayer());
    }

    public Point3D getPosition(){
        return getBlockInfo().getPosition();
    }

    public Point3D getTopSkewed(){
        if(getBlockInfo().getExtra() == null)
            return new Point3D(0, 0, 0);
        ExtraBlockProperty extraBlockProperty = getBlockInfo().getExtra();
        return (extraBlockProperty.getTopSkewed() == null)?
                new Point3D(0, 0, 0):
                extraBlockProperty.getTopSkewed();
    }

    public Point3D getBottomSkewed(){
        if(getBlockInfo().getExtra() == null)
            return new Point3D(0, 0, 0);
        ExtraBlockProperty extraBlockProperty = getBlockInfo().getExtra();
        return (extraBlockProperty.getBottomSkewed() == null)?
                new Point3D(0, 0, 0):
                extraBlockProperty.getBottomSkewed();
    }

    public Point3D getTopCenterPosition(){
        return getBlockInfo().getPosition()
                .add(new Point3D(0, -getBlockInfo().getHeight() / 2, 0))
                .add(getTopSkewed());
    }

    public Point3D getBottomCenterPosition(){
        return getBlockInfo().getPosition()
                .add(new Point3D(0, getBlockInfo().getHeight() / 2, 0))
                .add(getBottomSkewed());
    }

    public abstract void setHeight(double height);

    public abstract void setPosition(double x, double y, double z);

    protected abstract void createBlockModel(Layer layer);

    public abstract void reshapeBlockModel();
}
